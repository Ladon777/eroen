From 6bf2e68c2789a4b4121da3888d20771edceb6280 Mon Sep 17 00:00:00 2001
From: Michael Spencer <bigcheesegs@gmail.com>
Date: Mon, 11 Feb 2013 19:07:32 -0800
Subject: [PATCH 01/13] Kinda sorta write out dynamic stuff.

---
 include/lld/Core/STDExtras.h                       |  28 ++++++
 include/lld/ReaderWriter/ELFTargetInfo.h           |   6 ++
 lib/ReaderWriter/ELF/DefaultLayout.h               |  14 +--
 lib/ReaderWriter/ELF/SectionChunks.h               |  43 +++++++-
 lib/ReaderWriter/ELF/Writer.cpp                    | 110 ++++++++++++---------
 .../ELF/X86_64/X86_64TargetHandler.cpp             |   1 +
 lib/ReaderWriter/ELF/X86_64/X86_64TargetInfo.h     |   8 +-
 7 files changed, 154 insertions(+), 56 deletions(-)
 create mode 100644 include/lld/Core/STDExtras.h

diff --git a/include/lld/Core/STDExtras.h b/include/lld/Core/STDExtras.h
new file mode 100644
index 0000000..6c82342
--- /dev/null
+++ b/include/lld/Core/STDExtras.h
@@ -0,0 +1,28 @@
+//===- lld/Core/STDExtra.h - Helpers for the stdlib -----------------------===//
+//
+//                             The LLVM Linker
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLD_CORE_STD_EXTRA_H
+#define LLD_CORE_STD_EXTRA_H
+
+namespace lld {
+/// \brief Deleter for smart pointers that only calls the destructor. Memory is
+/// managed elsewhere. A common use of this is for things allocated with a
+/// BumpPtrAllocator.
+template <class T>
+struct destruct_delete {
+  void operator ()(T *ptr) {
+    ptr->~T();
+  }
+};
+
+template <class T>
+using unique_bump_ptr = std::unique_ptr<T, destruct_delete<T>>;
+} // end namespace lld
+
+#endif
diff --git a/include/lld/ReaderWriter/ELFTargetInfo.h b/include/lld/ReaderWriter/ELFTargetInfo.h
index f68387f..b1753b2 100644
--- a/include/lld/ReaderWriter/ELFTargetInfo.h
+++ b/include/lld/ReaderWriter/ELFTargetInfo.h
@@ -49,6 +49,12 @@ public:
     return false;
   }
 
+  /// \brief Does the output have dynamic sections.
+  bool isDynamic() const {
+    return _options._outputKind == OutputKind::DynamicExecutable ||
+           _options._outputKind == OutputKind::Shared;
+  }
+
   virtual ErrorOr<Reader &> getReader(const LinkerInput &input) const;
 
   virtual ErrorOr<Writer &> getWriter() const;
diff --git a/lib/ReaderWriter/ELF/DefaultLayout.h b/lib/ReaderWriter/ELF/DefaultLayout.h
index 8990b62..34ce44f 100644
--- a/lib/ReaderWriter/ELF/DefaultLayout.h
+++ b/lib/ReaderWriter/ELF/DefaultLayout.h
@@ -17,6 +17,7 @@
 #include "SegmentChunks.h"
 
 #include "lld/Core/LinkerOptions.h"
+#include "lld/Core/STDExtras.h"
 
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
@@ -26,6 +27,7 @@
 #include "llvm/ADT/StringExtras.h"
 #include "llvm/ADT/StringMap.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/StringSet.h"
 #include "llvm/ADT/StringSwitch.h"
 
 #include <map>
@@ -240,11 +242,11 @@ public:
   RelocationTable<ELFT> *getRelocationTable() {
     // Only create the relocation table if it is needed.
     if (!_relocationTable) {
-      _relocationTable = new (_allocator)
-          RelocationTable<ELFT>(_targetInfo, ".rela.plt", ORDER_REL);
-      addSection(_relocationTable);
+      _relocationTable.reset(new (_allocator)
+          RelocationTable<ELFT>(_targetInfo, ".rela.plt", ORDER_REL));
+      addSection(_relocationTable.get());
     }
-    return _relocationTable;
+    return _relocationTable.get();
   }
 
   uint64_t getTLSSize() const {
@@ -262,6 +264,7 @@ protected:
       SectionOrder sectionOrder);
 
 private:
+  llvm::BumpPtrAllocator _allocator;
   SectionMapT _sectionMap;
   MergedSectionMapT _mergedSectionMap;
   SegmentMapT _segmentMap;
@@ -270,9 +273,8 @@ private:
   std::vector<MergedSections<ELFT> *> _mergedSections;
   Header<ELFT> *_header;
   ProgramHeader<ELFT> *_programHeader;
-  RelocationTable<ELFT> *_relocationTable;
+  unique_bump_ptr<RelocationTable<ELFT>> _relocationTable;
   std::vector<AtomLayout *> _absoluteAtoms;
-  llvm::BumpPtrAllocator _allocator;
   const ELFTargetInfo &_targetInfo;
 };
 
diff --git a/lib/ReaderWriter/ELF/SectionChunks.h b/lib/ReaderWriter/ELF/SectionChunks.h
index 18d191b..a809875 100644
--- a/lib/ReaderWriter/ELF/SectionChunks.h
+++ b/lib/ReaderWriter/ELF/SectionChunks.h
@@ -546,7 +546,7 @@ class SymbolTable : public Section<ELFT> {
 public:
   typedef llvm::object::Elf_Sym_Impl<ELFT> Elf_Sym;
 
-  SymbolTable(const ELFTargetInfo &ti, const char *str, int32_t order);
+  SymbolTable(const ELFTargetInfo &ti, const char *str, int32_t order, bool dynamic = false);
 
   void addSymbol(const Atom *atom, int32_t sectionIndex, uint64_t addr = 0);
 
@@ -565,7 +565,7 @@ private:
 /// ELF Symbol Table 
 template <class ELFT>
 SymbolTable<ELFT>::SymbolTable(const ELFTargetInfo &ti, const char *str,
-                               int32_t order)
+                                     int32_t order, bool dynamic)
     : Section<ELFT>(ti, str) {
   this->setOrder(order);
   Elf_Sym *symbol = new (_symbolAllocate.Allocate<Elf_Sym>()) Elf_Sym;
@@ -716,6 +716,45 @@ public:
 private:
   std::vector<std::pair<const DefinedAtom &, const Reference &>> _relocs;
 };
+
+template <class ELFT> class DynamicTable : public Section<ELFT> {
+  typedef llvm::object::Elf_Dyn_Impl<ELFT> Elf_Dyn;
+  typedef std::vector<Elf_Dyn> EntriesT;
+
+public:
+  DynamicTable(const ELFTargetInfo &ti, StringRef str, int32_t order)
+      : Section<ELFT>(ti, str, llvm::ELF::SHT_DYNAMIC, DefinedAtom::permR__,
+                      order, Section<ELFT>::K_Default) {
+    this->setOrder(order);
+    this->_entSize = sizeof(Elf_Dyn);
+    this->_align2 = llvm::alignOf<Elf_Dyn>();
+    // Reserve space for the DT_NULL entry.
+    this->_fsize = sizeof(Elf_Dyn);
+    this->_msize = sizeof(Elf_Dyn);
+  }
+
+  range<typename EntriesT::iterator> entries() { return _entries; }
+
+  void addEntry(Elf_Dyn e) {
+    _entries.insert(e);
+    this->_fsize = (_entries.size() * sizeof(Elf_Dyn)) + sizeof(Elf_Dyn);
+    this->_msize = this->_fsize;
+  }
+
+  void write(ELFWriter *writer, llvm::FileOutputBuffer &buffer) {
+    uint8_t *chunkBuffer = buffer.getBufferStart();
+    uint8_t *dest = chunkBuffer + this->fileOffset();
+    // Add the null entry.
+    Elf_Dyn d;
+    d.d_tag = 0;
+    d.d_un.d_val = 0;
+    _entries.push_back(d);
+    std::memcpy(dest, _entries.data(), this->_fsize);
+  }
+
+private:
+  EntriesT _entries;
+};
 } // end namespace elf
 } // end namespace lld
 
diff --git a/lib/ReaderWriter/ELF/Writer.cpp b/lib/ReaderWriter/ELF/Writer.cpp
index 269607e..69c1d9b 100644
--- a/lib/ReaderWriter/ELF/Writer.cpp
+++ b/lib/ReaderWriter/ELF/Writer.cpp
@@ -38,10 +38,10 @@ private:
   void buildChunks(const File &file);
   virtual error_code writeFile(const File &File, StringRef path);
   void buildAtomToAddressMap();
-  void buildSymbolTable ();
+  void buildStaticSymbolTable(const File &file);
+  void buildDynamicSymbolTable(const File &file);
   void buildSectionHeaderTable();
   void assignSectionsWithNoSegments();
-  void addAbsoluteUndefinedSymbols(const File &File);
   void addDefaultAtoms();
   void addFiles(InputFiles&);
   void finalizeDefaultAtomValues();
@@ -52,19 +52,26 @@ private:
 
   void createDefaultSections();
 
+  llvm::BumpPtrAllocator _alloc;
+
   const ELFTargetInfo &_targetInfo;
   TargetHandler<ELFT> &_targetHandler;
 
   typedef llvm::DenseMap<const Atom *, uint64_t> AtomToAddress;
   AtomToAddress _atomToAddressMap;
-  llvm::BumpPtrAllocator _chunkAllocate;
   TargetLayout<ELFT> *_layout;
-  Header<ELFT> *_Header;
-  ProgramHeader<ELFT> *_programHeader;
-  SymbolTable<ELFT> * _symtab;
-  StringTable<ELFT> *_strtab;
-  StringTable<ELFT> *_shstrtab;
-  SectionHeader<ELFT> *_shdrtab;
+  unique_bump_ptr<Header<ELFT>> _Header;
+  unique_bump_ptr<ProgramHeader<ELFT>> _programHeader;
+  unique_bump_ptr<SymbolTable<ELFT>> _symtab;
+  unique_bump_ptr<StringTable<ELFT>> _strtab;
+  unique_bump_ptr<StringTable<ELFT>> _shstrtab;
+  unique_bump_ptr<SectionHeader<ELFT>> _shdrtab;
+  /// \name Dynamic sections.
+  /// @{
+  unique_bump_ptr<DynamicTable<ELFT>> _dynamicTable;
+  unique_bump_ptr<SymbolTable<ELFT>> _dynamicSymbolTable;
+  unique_bump_ptr<StringTable<ELFT>> _dynamicStringTable;
+  /// @}
   CRuntimeFile<ELFT> _runtimeFile;
 };
 
@@ -80,28 +87,18 @@ ExecutableWriter<ELFT>::ExecutableWriter(const ELFTargetInfo &ti)
 
 template <class ELFT>
 void ExecutableWriter<ELFT>::buildChunks(const File &file) {
-  for (const DefinedAtom *definedAtom : file.defined() ) {
+  for (const DefinedAtom *definedAtom : file.defined())
     _layout->addAtom(definedAtom);
-  }
-  /// Add all the absolute atoms to the layout
-  for (const AbsoluteAtom *absoluteAtom : file.absolute()) {
+  for (const AbsoluteAtom *absoluteAtom : file.absolute())
     _layout->addAtom(absoluteAtom);
-  }
 }
 
 template<class ELFT>
-void ExecutableWriter<ELFT>::buildSymbolTable () {
+void ExecutableWriter<ELFT>::buildStaticSymbolTable(const File &file) {
   for (auto sec : _layout->sections())
     if (auto section = dyn_cast<AtomSection<ELFT>>(sec))
       for (const auto &atom : section->atoms())
         _symtab->addSymbol(atom->_atom, section->ordinal(), atom->_virtualAddr);
-}
-
-template<class ELFT>
-void
-ExecutableWriter<ELFT>::addAbsoluteUndefinedSymbols(const File &file) {
-  // add all the absolute symbols that the layout contains to the output symbol
-  // table
   for (auto &atom : _layout->absoluteAtoms())
     _symtab->addSymbol(atom->_atom, ELF::SHN_ABS, atom->_virtualAddr);
   for (const UndefinedAtom *a : file.undefined())
@@ -109,7 +106,14 @@ ExecutableWriter<ELFT>::addAbsoluteUndefinedSymbols(const File &file) {
 }
 
 template<class ELFT>
-void ExecutableWriter<ELFT>::buildAtomToAddressMap () {
+void ExecutableWriter<ELFT>::buildDynamicSymbolTable(const File &file) {
+  for (const auto sla : file.sharedLibrary()) {
+    _dynamicSymbolTable->addSymbol(sla, ELF::SHN_UNDEF);
+  }
+}
+
+template<class ELFT>
+void ExecutableWriter<ELFT>::buildAtomToAddressMap() {
   for (auto sec : _layout->sections())
     if (auto section = dyn_cast<AtomSection<ELFT>>(sec))
       for (const auto &atom : section->atoms())
@@ -245,10 +249,9 @@ ExecutableWriter<ELFT>::writeFile(const File &file, StringRef path) {
   buildAtomToAddressMap();
 
   // Create symbol table and section string table
-  buildSymbolTable();
-
-  // add other symbols
-  addAbsoluteUndefinedSymbols(file);
+  buildStaticSymbolTable(file);
+  if (_targetInfo.isDynamic())
+    buildDynamicSymbolTable(file);
 
   // Finalize the layout by calling the finalize() functions
   _layout->finalize();
@@ -282,7 +285,7 @@ ExecutableWriter<ELFT>::writeFile(const File &file, StringRef path) {
     _Header->e_version(1);
   } else {
     // override the contents of the ELF Header
-    _targetHandler.setHeaderInfo(_Header);
+    _targetHandler.setHeaderInfo(_Header.get());
   }
   _Header->e_phoff(_programHeader->fileOffset());
   _Header->e_shoff(_shdrtab->fileOffset());
@@ -309,25 +312,38 @@ ExecutableWriter<ELFT>::writeFile(const File &file, StringRef path) {
 
 template<class ELFT>
 void ExecutableWriter<ELFT>::createDefaultSections() {
-  _Header = new Header<ELFT>(_targetInfo);
-  _programHeader = new ProgramHeader<ELFT>(_targetInfo);
-  _layout->setHeader(_Header);
-  _layout->setProgramHeader(_programHeader);
-
-  _symtab = new SymbolTable<
-      ELFT>(_targetInfo, ".symtab", DefaultLayout<ELFT>::ORDER_SYMBOL_TABLE);
-  _strtab = new StringTable<
-      ELFT>(_targetInfo, ".strtab", DefaultLayout<ELFT>::ORDER_STRING_TABLE);
-  _shstrtab = new StringTable<ELFT>(
-      _targetInfo, ".shstrtab", DefaultLayout<ELFT>::ORDER_SECTION_STRINGS);
-  _shdrtab = new SectionHeader<
-      ELFT>(_targetInfo, DefaultLayout<ELFT>::ORDER_SECTION_HEADERS);
-  _layout->addSection(_symtab);
-  _layout->addSection(_strtab);
-  _layout->addSection(_shstrtab);
-  _shdrtab->setStringSection(_shstrtab);
-  _symtab->setStringSection(_strtab);
-  _layout->addSection(_shdrtab);
+  _Header.reset(new (_alloc) Header<ELFT>(_targetInfo));
+  _programHeader.reset(new (_alloc) ProgramHeader<ELFT>(_targetInfo));
+  _layout->setHeader(_Header.get());
+  _layout->setProgramHeader(_programHeader.get());
+
+  _symtab.reset(new (_alloc) SymbolTable<ELFT>(
+      _targetInfo, ".symtab", DefaultLayout<ELFT>::ORDER_SYMBOL_TABLE));
+  _strtab.reset(new (_alloc) StringTable<ELFT>(
+      _targetInfo, ".strtab", DefaultLayout<ELFT>::ORDER_STRING_TABLE));
+  _shstrtab.reset(new (_alloc) StringTable<ELFT>(
+      _targetInfo, ".shstrtab", DefaultLayout<ELFT>::ORDER_SECTION_STRINGS));
+  _shdrtab.reset(new (_alloc) SectionHeader<ELFT>(
+      _targetInfo, DefaultLayout<ELFT>::ORDER_SECTION_HEADERS));
+  _layout->addSection(_symtab.get());
+  _layout->addSection(_strtab.get());
+  _layout->addSection(_shstrtab.get());
+  _shdrtab->setStringSection(_shstrtab.get());
+  _symtab->setStringSection(_strtab.get());
+  _layout->addSection(_shdrtab.get());
+
+  if (_targetInfo.isDynamic()) {
+    _dynamicTable.reset(new (_alloc) DynamicTable<ELFT>(
+        _targetInfo, ".dynamic", DefaultLayout<ELFT>::ORDER_DYNAMIC));
+    _dynamicStringTable.reset(new (_alloc) StringTable<ELFT>(
+        _targetInfo, ".dynstr", DefaultLayout<ELFT>::ORDER_DYNAMIC_STRINGS));
+    _dynamicSymbolTable.reset(new (_alloc) SymbolTable<ELFT>(
+        _targetInfo, ".dynsym", DefaultLayout<ELFT>::ORDER_DYNAMIC_SYMBOLS, true));
+    _layout->addSection(_dynamicTable.get());
+    _layout->addSection(_dynamicStringTable.get());
+    _layout->addSection(_dynamicSymbolTable.get());
+    _dynamicSymbolTable->setStringSection(_dynamicStringTable.get());
+  }
 
   // give a chance for the target to add sections
   _targetHandler.createDefaultSections();
diff --git a/lib/ReaderWriter/ELF/X86_64/X86_64TargetHandler.cpp b/lib/ReaderWriter/ELF/X86_64/X86_64TargetHandler.cpp
index bad758c..69e7888 100644
--- a/lib/ReaderWriter/ELF/X86_64/X86_64TargetHandler.cpp
+++ b/lib/ReaderWriter/ELF/X86_64/X86_64TargetHandler.cpp
@@ -97,6 +97,7 @@ ErrorOr<void> X86_64TargetRelocationHandler::applyRelocation(
     break;
   }
   // Runtime only relocations. Ignore here.
+  case R_X86_64_RELATIVE:
   case R_X86_64_IRELATIVE:
     break;
 
diff --git a/lib/ReaderWriter/ELF/X86_64/X86_64TargetInfo.h b/lib/ReaderWriter/ELF/X86_64/X86_64TargetInfo.h
index 146bd25..1db39aa 100644
--- a/lib/ReaderWriter/ELF/X86_64/X86_64TargetInfo.h
+++ b/lib/ReaderWriter/ELF/X86_64/X86_64TargetInfo.h
@@ -40,7 +40,13 @@ public:
 
   virtual bool isRuntimeRelocation(const DefinedAtom &,
                                    const Reference &r) const {
-    return r.kind() == llvm::ELF::R_X86_64_IRELATIVE;
+    switch (r.kind()){
+    case llvm::ELF::R_X86_64_RELATIVE:
+    case llvm::ELF::R_X86_64_IRELATIVE:
+      return true;
+    default:
+      return false;
+    }
   }
 
   virtual ErrorOr<int32_t> relocKindFromString(StringRef str) const;
-- 
1.8.1.2

