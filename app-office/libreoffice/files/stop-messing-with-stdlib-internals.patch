much from <http://cgit.freedesktop.org/libreoffice/core/tree/bridges/source/cpp_uno/gcc3_macosx_x86-64/except.cxx>
diff -ur a-libreoffice-4.1.0.1/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx libreoffice-4.1.0.1/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx
--- a-libreoffice-4.1.0.1/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	2013-06-20 09:13:52.000000000 +0200
+++ libreoffice-4.1.0.1/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	2013-07-11 14:16:40.998562174 +0200
@@ -53,6 +53,38 @@
 
 namespace CPPU_CURRENT_NAMESPACE
 {
+struct FAKE_type_info: public std::type_info {
+    FAKE_type_info(char const * name): type_info(name) {}
+};
+struct FAKE_si_class_type_info: public FAKE_type_info {
+    FAKE_si_class_type_info(char const * name, std::type_info const * theBase):
+        FAKE_type_info(name), base(theBase) {}
+
+    std::type_info const * base;
+        // actually a __cxxabiv1::__class_type_info pointer
+};
+struct Base {};
+struct Derived: Base {};
+
+std::type_info * create_FAKE_class_type_info(char const * name) {
+    std::type_info * p = new FAKE_type_info(name);
+        // cxxabiv1::__class_type_info has no data members in addition to
+        // std::type_info
+    *reinterpret_cast< void ** >(p) = *reinterpret_cast< void * const * >(
+        &typeid(Base));
+        // copy correct __cxxabiv1::__class_type_info vtable into place
+    return p;
+}
+
+std::type_info * create_FAKE_si_class_type_info(
+    char const * name, std::type_info const * base)
+{
+    std::type_info * p = new FAKE_si_class_type_info(name, base);
+    *reinterpret_cast< void ** >(p) = *reinterpret_cast< void * const * >(
+        &typeid(Derived));
+        // copy correct __cxxabiv1::__si_class_type_info vtable into place
+    return p;
+}
 
 //==================================================================================================
 static OUString toUNOname( char const * p ) SAL_THROW(())
@@ -180,13 +212,13 @@
                     // ensure availability of base
                     type_info * base_rtti = getRTTI(
                         (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
-                    rtti = new __si_class_type_info(
-                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                    rtti = create_FAKE_si_class_type_info(
+                        strdup( rttiName ), base_rtti );
                 }
                 else
                 {
                     // this class has no base class
-                    rtti = new __class_type_info( strdup( rttiName ) );
+                    rtti = create_FAKE_class_type_info( strdup( rttiName ) );
                 }
 
                 pair< t_rtti_map::iterator, bool > insertion (

