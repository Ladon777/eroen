--- a/libreoffice-4.1.0.1/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	2013-07-13 22:47:29.146836141 +0200
+++ b/libreoffice-4.1.0.1/bridges/source/cpp_uno/gcc3_linux_x86-64/except.cxx	2013-07-13 22:47:24.428793311 +0200
@@ -53,38 +53,6 @@
 
 namespace CPPU_CURRENT_NAMESPACE
 {
-struct FAKE_type_info: public std::type_info {
-    FAKE_type_info(char const * name): type_info(name) {}
-};
-struct FAKE_si_class_type_info: public FAKE_type_info {
-    FAKE_si_class_type_info(char const * name, std::type_info const * theBase):
-        FAKE_type_info(name), base(theBase) {}
-
-    std::type_info const * base;
-        // actually a __cxxabiv1::__class_type_info pointer
-};
-struct Base {};
-struct Derived: Base {};
-
-std::type_info * create_FAKE_class_type_info(char const * name) {
-    std::type_info * p = new FAKE_type_info(name);
-        // cxxabiv1::__class_type_info has no data members in addition to
-        // std::type_info
-    *reinterpret_cast< void ** >(p) = *reinterpret_cast< void * const * >(
-        &typeid(Base));
-        // copy correct __cxxabiv1::__class_type_info vtable into place
-    return p;
-}
-
-std::type_info * create_FAKE_si_class_type_info(
-    char const * name, std::type_info const * base)
-{
-    std::type_info * p = new FAKE_si_class_type_info(name, base);
-    *reinterpret_cast< void ** >(p) = *reinterpret_cast< void * const * >(
-        &typeid(Derived));
-        // copy correct __cxxabiv1::__si_class_type_info vtable into place
-    return p;
-}
 
 //==================================================================================================
 static OUString toUNOname( char const * p ) SAL_THROW(())
@@ -202,30 +170,8 @@
             t_rtti_map::const_iterator iFind2( m_generatedRttis.find( unoName ) );
             if (iFind2 == m_generatedRttis.end())
             {
-                // we must generate it !
-                // symbol and rtti-name is nearly identical,
-                // the symbol is prefixed with _ZTI
-                char const * rttiName = symName.getStr() +4;
-#if OSL_DEBUG_LEVEL > 1
-                fprintf( stderr,"generated rtti for %s\n", rttiName );
-#endif
-                if (pTypeDescr->pBaseTypeDescription)
-                {
-                    // ensure availability of base
-                    type_info * base_rtti = getRTTI(
-                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
-                    rtti = create_FAKE_si_class_type_info(
-                        strdup( rttiName ), base_rtti );
-                }
-                else
-                {
-                    // this class has no base class
-                    rtti = create_FAKE_class_type_info( strdup( rttiName ) );
-                }
-
-                pair< t_rtti_map::iterator, bool > insertion (
-                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
-                SAL_WARN_IF( !insertion.second, "bridges", "key " << unoName << " already in generated rtti map" );
+                OSL_FAIL("Cannot generate type_infos with libc++, sigh");
+                return NULL;
             }
             else // taking already generated rtti
             {

